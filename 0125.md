__리스트 내 같은 인덱스의 합 출력하기__

```python
lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for idx in range(len(lst[0])): # 각 리스트의 인덱스 0에 대한 반복. 리스트0은 3개 있음
    result = 0
    for each_lst in range(len(lst)): # 각 리스트에 대한 반복
        result += lst[each_lst][idx] # lst[0][0] + lst[1][0] + lst[2][0]...
    print(result) # 결과값 3개 출력.
```

다만, 각 리스트의 length가 동일하지 않을 때는 계산이 불가능하다. 왜냐하면 첫 기준값(반복값)을 3으로 설정했기 때문에. 만약 lst[2]가 [7, 8]이라고 가정한다면 2번째 for문에서

```python
result += lst[2][2]
```

라는 ''없는 값'' 때문에 실행되지 않는다.

-----------------------------

__join__

join같은 경우, 리스트 내 문자들을 합칠 수도 있고 나눌 수도 있다.

```python
' '.join(변수 이름)
```

' ' 사이에 있는 separator(구분자)로 나머지를 잇는다. 기준은 잘 모르겠으니 써보면서 익혀야겠다.

--------------------

__메서드와 함수의 차이점__

메서드 = .메서드()를 형태며 원본을 바꾸는 녀석도 있고 아닌 녀석들도 있다. .sort()는 원본 바꿈. 근데 프린트하면 None을 반환한다.

-----------------

pop은 위치에 있는 값을 삭제하며, remove는 '값'을 찾아서 삭제한다.

.index()는 값을 찾아 위치값을 반환한다.

---------------

__리스트 내 원하는 값의 인덱스 확인하기__

```python
def find_index(lst):
    if x in lst:
        return lst.index(x)
    else:
        return -1
```

---------------

딕셔너리에서 get과 setdefault의 차이.

.get('찾는 값', 없을 때 반환값) / .setdefault('찾는 값', 없을 때 딕셔너리에 넣을 value)

__딕셔너리 update 메서드__

```python
dict.update(키값='넣을 값')
```

키 값에 쿼터를 넣지 않는 이유는 '='가 들어가기 때문에. 생각해보면 변수는 원래 쿼터 안씌워준다.

리스트의 extend와 마찬가지로 __셋 형태__로 추가할 수 있다.
