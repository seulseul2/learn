자료형은 3가지

- Boolean
- Numeric
  - int
  - float
  - complex
- String



__Int__는 Overflow가 발생하지 않음.

2진수 : 0b (바이너리)

8진수 : 0o (문어)

16진수 : 0x (헥사뭐시기)

Immutable : str(문자열)은 바꿀 수가 없다.

literable : 반복 가능하다.



__Float__

계산 실수가 나올수도 있음.

```python
abs(a - b) <= 1e-10
```

처럼 매우 작은 수와 비교해서 __차이가 매우 적다__는 사실을 증명하면 된다. __1e-10 -> 1 * (10의 -10승).__ 즉 매우 작은 수다.



__String__의 특징 2가지

1) Immutable (바꿀 수 없음)
2) Iterable (반복 가능함)



__Escape sequence__

\n(줄 바꿈) \t(탭) \r(캐리지리턴) \0(널)

\\\\\(\\) \\'(단일인용부호) \\"(이중인용부호) 

82pg. list(range(1, 5, 2)) 알아두기.



__String Interpolation__

1. %-formatting
2. str.format()
3. f-strings



__Container__

+ 시퀀스형
  + 리스트 : [] , list()
  + 튜플 : (), tuple()      __수정 불가능한__ 시퀀스. __단일 항목의 경우, 쉼표를 붙여줘야 한다__
  + 레인지
+ 비시퀀스형
  + 셋 : {} 안됨(이건 딕셔너리), set()      __순서가 없어 별도의 값에 접근할 수 없다__
  + 딕셔너리 : {}, dict()

blank = {} 이거는 dic

set을 만들고 싶으면 set()로 만들기.

또한, set은 순서가 없기 때문에 인덱스 접근이 불가능하다.



p98. set을 사용했을 때 가나다 순서대로 나오는 게 신기하다.



p.101 : value에는 숫자, 리스트 무엇이든 들어가지만, key에는 리스트가 들어갈 수 없다.

접근할 때는 __키__를 활용해서 __Value__를 찾는거지 반대는 불가능하다. 키는 고유한 값, 중복도 안됨.



107 : 3.5같은 경우는 int로 바꿔도 정수가 아니기 때문에 변환이 불가능함.



151pg

range와 dictionary로는 바꿀 수 없다. range는 숫자를 나열했고, dic은 key와 value로 이루어졌기 때문이다.

또한, dictionary를 변환할 때는 key만 나오는 경우가 많다. key만 알고 있으면 value는 언제든 나오기 때문이다.



112pg

몫만 따로 보실 수가 있고 (//), 나머지만 따로 볼 수가 있다(%)

자료를 보는 형식은 오른쪽에서 왼쪽으로 할당하는 느낌



120pg

and는 두 번째 값까지 봐야되기 때문에 뒷 값이 출력된다.

반면 or은 앞에꺼만 True면 무조건 True라서 앞 값이 출력된다.



124pg

in이랑 not in은 꿀기능이다.



126

range는 숫자 통으로만 쓰는거구나... 연산같은거 할 생각하지 말아야겠다.



128

IndexError : 없는 인덱스에 접근한거임. 질문하지마셈ㅋㅋ 내용좀 살펴봐 제발



어떠한 "How-to"를 배우셨나요?



string : 문자들의 나열

[list] : 요소들의 시퀀스

(tuple) : 변경 불가능한 요소들의 시퀀스

{set} : 중복 없는 요소들의 시퀀스

{k:v} : key : value